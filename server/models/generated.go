// generated by `make gen`, do not modify
package models

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"

	"gorm.io/gorm"
	"gorm.io/gorm/schema"
	"vsoutlook.com/vsoutlook/models/db"
)

var GetUser = Get[User]
var ActiveUser = Active[User]
var UserBy = QueryOne[User]
var UsersBy = QueryMulti[User]
var UsersBy3 = QueryMulti3[User]
var UsersBy4 = QueryMulti4[User]
var UsersByIDs = ByIDs[User]

func (User) TableName() string {
	return "users"
}

var GetTmplType = Get[TmplType]
var ActiveTmplType = Active[TmplType]
var TmplTypeBy = QueryOne[TmplType]
var TmplTypesBy = QueryMulti[TmplType]
var TmplTypesBy3 = QueryMulti3[TmplType]
var TmplTypesBy4 = QueryMulti4[TmplType]
var TmplTypesByIDs = ByIDs[TmplType]

func (TmplType) TableName() string {
	return "tmpl_types"
}

var GetTmpl = Get[Tmpl]
var ActiveTmpl = Active[Tmpl]
var TmplBy = QueryOne[Tmpl]
var TmplsBy = QueryMulti[Tmpl]
var TmplsBy3 = QueryMulti3[Tmpl]
var TmplsBy4 = QueryMulti4[Tmpl]
var TmplsByIDs = ByIDs[Tmpl]

func (Tmpl) TableName() string {
	return "tmpls"
}

var GetDevice = Get[Device]
var ActiveDevice = Active[Device]
var DeviceBy = QueryOne[Device]
var DevicesBy = QueryMulti[Device]
var DevicesBy3 = QueryMulti3[Device]
var DevicesBy4 = QueryMulti4[Device]
var DevicesByIDs = ByIDs[Device]

func (Device) TableName() string {
	return "devices"
}

func (Node) TableName() string {
	return "nodes"
}

func (Settings) TableName() string {
	return "settings"
}

// for gorm
func (d TmplRequirement) Value() (driver.Value, error) {
	return json.Marshal(d)
}

func (d *TmplRequirement) Scan(value any) error {
	b, ok := value.([]byte)
	if !ok {
		return errors.New("type assertion to []byte failed")
	}
	return json.Unmarshal(b, &d)
}

func (TmplRequirement) GormDBDataType(gormDb *gorm.DB, field *schema.Field) string {
	return db.JSONField(gormDb)
}

func (s Uint32Slice) Value() (driver.Value, error) {
	return json.Marshal(s)
}

func (s *Uint32Slice) Scan(value interface{}) error {
	if value == nil {
		*s = make(Uint32Slice, 0)
		return nil
	}

	switch v := value.(type) {
	case string:
		return json.Unmarshal([]byte(v), s)
	case []byte:
		return json.Unmarshal(v, s)
	default:
		return fmt.Errorf("invalid scan type for Uint32Slice: %T", v)
	}
}

func (m MapUint32Slice) Value() (driver.Value, error) {
	return json.Marshal(m)
}

func (m *MapUint32Slice) Scan(value interface{}) error {
	if value == nil {
		*m = make(MapUint32Slice)
		return nil
	}

	switch v := value.(type) {
	case string:
		return json.Unmarshal([]byte(v), m)
	case []byte:
		return json.Unmarshal(v, m)
	default:
		return fmt.Errorf("invalid scan type for MapUint32Slice: %T", v)
	}
}
